[
  {
    "path": "/home/ubuntu/repos/typescript-testing-masterclass/src/examples/accessibility-testing/accessibility-testing.test.tsx",
    "relativePath": "accessibility-testing/accessibility-testing.test.tsx",
    "fileName": "accessibility-testing.test.tsx",
    "dirName": "accessibility-testing",
    "content": "/**\n * This test file demonstrates techniques for testing accessibility in React components\n * with Vitest, Testing Library, and jest-axe.\n */\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport React from 'react';\nimport { render, screen, fireEvent, waitFor, act } from '@testing-library/react';\nimport { axe, toHaveNoViolations } from 'jest-axe';\nimport '@testing-library/jest-dom';\nimport { AccessibleForm } from './accessible-form';\n\nexpect.extend(toHaveNoViolations);\n\ndescribe('Accessibility Testing', () => {\n  const mockSubmit = vi.fn();\n  \n  beforeEach(() => {\n    mockSubmit.mockClear();\n  });\n  \n  describe('Automated Accessibility Testing with jest-axe', () => {\n    it('should have no accessibility violations', async () => {\n      const { container } = render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const results = await axe(container);\n      \n      expect(results).toHaveNoViolations();\n    });\n    \n    it('should have no accessibility violations when showing errors', async () => {\n      const { container } = render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const results = await axe(container);\n      expect(results).toHaveNoViolations();\n    });\n    \n    it('should have no accessibility violations when showing success message', async () => {\n      const { container } = render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } });\n      fireEvent.change(screen.getByTestId('email-input'), { target: { value: 'john@example.com' } });\n      fireEvent.change(screen.getByTestId('message-input'), { target: { value: 'Test message' } });\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const results = await axe(container);\n      expect(results).toHaveNoViolations();\n    });\n  });\n  \n  describe('Testing ARIA Attributes', () => {\n    it('should have proper aria-required attributes', () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      expect(screen.getByTestId('name-input')).toHaveAttribute('aria-required', 'true');\n      expect(screen.getByTestId('email-input')).toHaveAttribute('aria-required', 'true');\n      expect(screen.getByTestId('message-input')).toHaveAttribute('aria-required', 'true');\n    });\n    \n    it('should set aria-invalid when validation fails', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      expect(screen.getByTestId('name-input')).toHaveAttribute('aria-invalid', 'true');\n      expect(screen.getByTestId('email-input')).toHaveAttribute('aria-invalid', 'true');\n      expect(screen.getByTestId('message-input')).toHaveAttribute('aria-invalid', 'true');\n    });\n    \n    it('should connect error messages with inputs using aria-describedby', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const nameInput = screen.getByTestId('name-input');\n      const nameErrorId = nameInput.getAttribute('aria-describedby');\n      expect(nameErrorId).toBeTruthy();\n      \n      const nameError = screen.getByTestId('name-error');\n      expect(nameError).toHaveAttribute('id', nameErrorId);\n    });\n  });\n  \n  describe('Testing Focus Management', () => {\n    it('should focus the first field with an error after failed submission', async () => {\n      expect(true).toBe(true);\n    });\n    \n    it('should focus the submit button after successful submission', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } });\n      fireEvent.change(screen.getByTestId('email-input'), { target: { value: 'john@example.com' } });\n      fireEvent.change(screen.getByTestId('message-input'), { target: { value: 'Test message' } });\n      \n      const submitButton = screen.getByTestId('submit-button');\n      \n      await act(async () => {\n        fireEvent.click(submitButton);\n      });\n      \n      await waitFor(() => {\n        expect(document.activeElement).toBe(submitButton);\n      });\n    });\n  });\n  \n  describe('Testing Keyboard Navigation', () => {\n    it('should allow form completion using only the keyboard', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const nameInput = screen.getByTestId('name-input');\n      const emailInput = screen.getByTestId('email-input');\n      const messageInput = screen.getByTestId('message-input');\n      const prioritySelect = screen.getByTestId('priority-select');\n      const subscribeCheckbox = screen.getByTestId('subscribe-checkbox');\n      const submitButton = screen.getByTestId('submit-button');\n      \n      await act(async () => {\n        nameInput.focus();\n        fireEvent.change(nameInput, { target: { value: 'John Doe' } });\n        \n        emailInput.focus();\n        fireEvent.change(emailInput, { target: { value: 'john@example.com' } });\n        \n        messageInput.focus();\n        fireEvent.change(messageInput, { target: { value: 'Test message' } });\n        \n        prioritySelect.focus();\n        fireEvent.change(prioritySelect, { target: { value: 'high' } });\n        \n        subscribeCheckbox.focus();\n        fireEvent.click(subscribeCheckbox);\n        \n        submitButton.focus();\n        fireEvent.click(submitButton);\n      });\n      \n      await waitFor(() => {\n        expect(mockSubmit).toHaveBeenCalledTimes(1);\n      });\n      \n      expect(mockSubmit).toHaveBeenCalledWith({\n        name: 'John Doe',\n        email: 'john@example.com',\n        message: 'Test message',\n        priority: 'high',\n        subscribe: true\n      });\n    });\n  });\n  \n  describe('Testing Screen Reader Announcements', () => {\n    it('should announce form errors to screen readers', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const nameError = screen.getByTestId('name-error');\n      expect(nameError).toHaveAttribute('aria-live', 'polite');\n      expect(nameError).toHaveTextContent('Name is required');\n    });\n    \n    it('should announce success message to screen readers', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } });\n      fireEvent.change(screen.getByTestId('email-input'), { target: { value: 'john@example.com' } });\n      fireEvent.change(screen.getByTestId('message-input'), { target: { value: 'Test message' } });\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      expect(screen.getByTestId('visible-success-message')).toBeInTheDocument();\n      \n      const srMessage = screen.getByTestId('success-message');\n      expect(srMessage).toHaveAttribute('aria-live', 'polite');\n    });\n  });\n  \n  describe('Testing Color Contrast', () => {\n    \n    it('should have sufficient color contrast for error messages', () => {\n      \n      \n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const nameError = screen.getByTestId('name-error');\n      expect(nameError).toHaveClass('error-message');\n    });\n  });\n  \n  describe('Testing Form Validation', () => {\n    it('should validate email format', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } });\n      fireEvent.change(screen.getByTestId('email-input'), { target: { value: 'invalid-email' } });\n      fireEvent.change(screen.getByTestId('message-input'), { target: { value: 'Test message' } });\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      expect(screen.getByTestId('email-error')).toHaveTextContent('Please enter a valid email address');\n      expect(mockSubmit).not.toHaveBeenCalled();\n    });\n    \n    it('should clear error messages when fields are edited', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      expect(screen.getByTestId('name-error')).toBeInTheDocument();\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } });\n      \n      expect(screen.queryByTestId('name-error')).not.toBeInTheDocument();\n    });\n  });\n});\n",
    "description": "Comprehensive guide to accessibility testing in React applications. Learn how to use jest-axe to verify WCAG compliance and test keyboard navigation and screen reader compatibility.",
    "isTestFile": true,
    "category": "e2e-tests",
    "codeBlocks": [
      {
        "title": "should have no accessibility violations",
        "code": "it('should have no accessibility violations', async () => {\n      const { container } = render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const results = await axe(container);\n      \n      expect(results).toHaveNoViolations();\n    })",
        "type": "test-case"
      },
      {
        "title": "should have no accessibility violations when showing errors",
        "code": "it('should have no accessibility violations when showing errors', async () => {\n      const { container } = render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const results = await axe(container);\n      expect(results).toHaveNoViolations();\n    })",
        "type": "test-case"
      },
      {
        "title": "should have no accessibility violations when showing success message",
        "code": "it('should have no accessibility violations when showing success message', async () => {\n      const { container } = render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } })",
        "type": "test-case"
      },
      {
        "title": "should have proper aria-required attributes",
        "code": "it('should have proper aria-required attributes', () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      expect(screen.getByTestId('name-input')).toHaveAttribute('aria-required', 'true');\n      expect(screen.getByTestId('email-input')).toHaveAttribute('aria-required', 'true');\n      expect(screen.getByTestId('message-input')).toHaveAttribute('aria-required', 'true');\n    })",
        "type": "test-case"
      },
      {
        "title": "should set aria-invalid when validation fails",
        "code": "it('should set aria-invalid when validation fails', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      expect(screen.getByTestId('name-input')).toHaveAttribute('aria-invalid', 'true');\n      expect(screen.getByTestId('email-input')).toHaveAttribute('aria-invalid', 'true');\n      expect(screen.getByTestId('message-input')).toHaveAttribute('aria-invalid', 'true');\n    })",
        "type": "test-case"
      },
      {
        "title": "should connect error messages with inputs using aria-describedby",
        "code": "it('should connect error messages with inputs using aria-describedby', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const nameInput = screen.getByTestId('name-input');\n      const nameErrorId = nameInput.getAttribute('aria-describedby');\n      expect(nameErrorId).toBeTruthy();\n      \n      const nameError = screen.getByTestId('name-error');\n      expect(nameError).toHaveAttribute('id', nameErrorId);\n    })",
        "type": "test-case"
      },
      {
        "title": "should focus the first field with an error after failed submission",
        "code": "it('should focus the first field with an error after failed submission', async () => {\n      expect(true).toBe(true);\n    })",
        "type": "test-case"
      },
      {
        "title": "should focus the submit button after successful submission",
        "code": "it('should focus the submit button after successful submission', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } })",
        "type": "test-case"
      },
      {
        "title": "should allow form completion using only the keyboard",
        "code": "it('should allow form completion using only the keyboard', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const nameInput = screen.getByTestId('name-input');\n      const emailInput = screen.getByTestId('email-input');\n      const messageInput = screen.getByTestId('message-input');\n      const prioritySelect = screen.getByTestId('priority-select');\n      const subscribeCheckbox = screen.getByTestId('subscribe-checkbox');\n      const submitButton = screen.getByTestId('submit-button');\n      \n      await act(async () => {\n        nameInput.focus();\n        fireEvent.change(nameInput, { target: { value: 'John Doe' } })",
        "type": "test-case"
      },
      {
        "title": "should announce form errors to screen readers",
        "code": "it('should announce form errors to screen readers', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const nameError = screen.getByTestId('name-error');\n      expect(nameError).toHaveAttribute('aria-live', 'polite');\n      expect(nameError).toHaveTextContent('Name is required');\n    })",
        "type": "test-case"
      },
      {
        "title": "should announce success message to screen readers",
        "code": "it('should announce success message to screen readers', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } })",
        "type": "test-case"
      },
      {
        "title": "should have sufficient color contrast for error messages",
        "code": "it('should have sufficient color contrast for error messages', () => {\n      \n      \n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const nameError = screen.getByTestId('name-error');\n      expect(nameError).toHaveClass('error-message');\n    })",
        "type": "test-case"
      },
      {
        "title": "should validate email format",
        "code": "it('should validate email format', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } })",
        "type": "test-case"
      },
      {
        "title": "should clear error messages when fields are edited",
        "code": "it('should clear error messages when fields are edited', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      expect(screen.getByTestId('name-error')).toBeInTheDocument();\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } })",
        "type": "test-case"
      },
      {
        "title": "Accessibility Testing",
        "code": "describe('Accessibility Testing', () => {\n  const mockSubmit = vi.fn();\n  \n  beforeEach(() => {\n    mockSubmit.mockClear();\n  })",
        "type": "describe-block"
      },
      {
        "title": "Automated Accessibility Testing with jest-axe",
        "code": "describe('Automated Accessibility Testing with jest-axe', () => {\n    it('should have no accessibility violations', async () => {\n      const { container } = render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const results = await axe(container);\n      \n      expect(results).toHaveNoViolations();\n    })",
        "type": "describe-block"
      },
      {
        "title": "Testing ARIA Attributes",
        "code": "describe('Testing ARIA Attributes', () => {\n    it('should have proper aria-required attributes', () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      expect(screen.getByTestId('name-input')).toHaveAttribute('aria-required', 'true');\n      expect(screen.getByTestId('email-input')).toHaveAttribute('aria-required', 'true');\n      expect(screen.getByTestId('message-input')).toHaveAttribute('aria-required', 'true');\n    })",
        "type": "describe-block"
      },
      {
        "title": "Testing Focus Management",
        "code": "describe('Testing Focus Management', () => {\n    it('should focus the first field with an error after failed submission', async () => {\n      expect(true).toBe(true);\n    })",
        "type": "describe-block"
      },
      {
        "title": "Testing Keyboard Navigation",
        "code": "describe('Testing Keyboard Navigation', () => {\n    it('should allow form completion using only the keyboard', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const nameInput = screen.getByTestId('name-input');\n      const emailInput = screen.getByTestId('email-input');\n      const messageInput = screen.getByTestId('message-input');\n      const prioritySelect = screen.getByTestId('priority-select');\n      const subscribeCheckbox = screen.getByTestId('subscribe-checkbox');\n      const submitButton = screen.getByTestId('submit-button');\n      \n      await act(async () => {\n        nameInput.focus();\n        fireEvent.change(nameInput, { target: { value: 'John Doe' } })",
        "type": "describe-block"
      },
      {
        "title": "Testing Screen Reader Announcements",
        "code": "describe('Testing Screen Reader Announcements', () => {\n    it('should announce form errors to screen readers', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const nameError = screen.getByTestId('name-error');\n      expect(nameError).toHaveAttribute('aria-live', 'polite');\n      expect(nameError).toHaveTextContent('Name is required');\n    })",
        "type": "describe-block"
      },
      {
        "title": "Testing Color Contrast",
        "code": "describe('Testing Color Contrast', () => {\n    \n    it('should have sufficient color contrast for error messages', () => {\n      \n      \n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      const submitButton = screen.getByTestId('submit-button');\n      fireEvent.click(submitButton);\n      \n      const nameError = screen.getByTestId('name-error');\n      expect(nameError).toHaveClass('error-message');\n    })",
        "type": "describe-block"
      },
      {
        "title": "Testing Form Validation",
        "code": "describe('Testing Form Validation', () => {\n    it('should validate email format', async () => {\n      render(<AccessibleForm onSubmit={mockSubmit} />);\n      \n      fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } })",
        "type": "describe-block"
      }
    ]
  },
  {
    "path": "/home/ubuntu/repos/typescript-testing-masterclass/src/examples/async-testing/async-testing.test.ts",
    "relativePath": "async-testing/async-testing.test.ts",
    "fileName": "async-testing.test.ts",
    "dirName": "async-testing",
    "content": "/**\n * This test file demonstrates techniques for testing asynchronous code\n * with Vitest and TypeScript, focusing on promises, async/await, and race conditions.\n */\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { ApiClient, User } from './api-client';\n\nvi.setConfig({ testTimeout: 60000 });\n\ndescribe('Testing Asynchronous Code', () => {\n  let apiClient: ApiClient;\n  \n  beforeEach(() => {\n    apiClient = new ApiClient();\n    \n    vi.useFakeTimers();\n  });\n  \n  afterEach(() => {\n    vi.restoreAllMocks();\n    vi.useRealTimers();\n  });\n  \n  describe('Basic Promise Testing', () => {\n    it('should resolve with user data for valid ID', async () => {\n      const userId = 1;\n      \n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      await expect(promise).resolves.toEqual(expect.objectContaining({\n        data: expect.objectContaining({\n          id: userId,\n          name: `User ${userId}`,\n          email: `user${userId}@example.com`\n        }),\n        status: 200\n      }));\n    });\n    \n    it('should reject for invalid user ID', async () => {\n      const userId = -1;\n      \n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      await expect(promise).rejects.toThrow('User not found');\n    });\n    \n    it('should handle promise rejection with try/catch', async () => {\n      const userId = -1;\n      \n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      try {\n        await promise;\n        expect.fail('Promise should have been rejected');\n      } catch (error) {\n        expect(error).toBeInstanceOf(Error);\n        expect((error as Error).message).toBe('User not found');\n      }\n    }, 60000);\n  });\n  \n  describe('Testing Async/Await Functions', () => {\n    it('should create a user with valid data', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com'\n      };\n      \n      const promise = apiClient.createUser(userData);\n      vi.runAllTimers();\n      const result = await promise;\n      \n      expect(result.status).toBe(201);\n      expect(result.data).toEqual(expect.objectContaining({\n        id: expect.any(Number),\n        name: userData.name,\n        email: userData.email\n      }));\n    });\n    \n    it('should throw for invalid user data', async () => {\n      const invalidUserData = {\n        name: '',\n        email: 'john@example.com'\n      };\n      \n      const createPromise = apiClient.createUser(invalidUserData);\n      vi.runAllTimers();\n      \n      await expect(createPromise).rejects.toThrow('Invalid user data');\n    });\n  });\n  \n  describe('Testing Concurrent Operations', () => {\n    it('should fetch multiple users concurrently', async () => {\n      const userIds = [1, 2, 3];\n      \n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const promise = apiClient.getUsers(userIds);\n      vi.runAllTimers();\n      const result = await promise;\n      \n      expect(result.data).toHaveLength(userIds.length);\n      expect(result.data[0].id).toBe(userIds[0]);\n      expect(result.data[1].id).toBe(userIds[1]);\n      expect(result.data[2].id).toBe(userIds[2]);\n    });\n    \n    it('should handle errors in concurrent operations', async () => {\n      const userIds = [1, -1, 3]; // One invalid ID\n      \n      const promise = apiClient.getUsers(userIds);\n      vi.runAllTimers();\n      \n      await expect(promise).rejects.toThrow('Failed to fetch users');\n    });\n  });\n  \n  describe('Testing Race Conditions', () => {\n    it('should handle timeout race conditions', async () => {\n      const userId = 1;\n      \n      const getUserSpy = vi.spyOn(apiClient as any, 'getUser');\n      getUserSpy.mockImplementationOnce(async () => {\n        await new Promise(resolve => setTimeout(resolve, 10000)); // Very long delay\n        return { data: { id: userId, name: 'User 1', email: 'user1@example.com' } };\n      });\n      \n      const promise = apiClient.getUserWithTimeout(userId);\n      \n      vi.advanceTimersByTime(6000);\n      \n      const result = await promise;\n      expect(result).toBeNull();\n    });\n    \n    it('should return data when request completes before timeout', async () => {\n      const userId = 1;\n      \n      const getUserSpy = vi.spyOn(apiClient as any, 'getUser');\n      getUserSpy.mockResolvedValueOnce({\n        data: { id: userId, name: 'User 1', email: 'user1@example.com' },\n        status: 200,\n        message: 'Success'\n      });\n      \n      const promise = apiClient.getUserWithTimeout(userId);\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      expect(result).not.toBeNull();\n      expect(result?.data.id).toBe(userId);\n    });\n  });\n  \n  describe('Advanced Timer Techniques', () => {\n    it('should test sequential async operations with runOnlyPendingTimers', async () => {\n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const createUserSpy = vi.spyOn(apiClient, 'createUser');\n      const userData = { name: 'Test User', email: 'test@example.com' };\n      \n      const createPromise = apiClient.createUser(userData);\n      \n      vi.runOnlyPendingTimers();\n      \n      await createPromise;\n      \n      const getUserPromise = apiClient.getUser(1);\n      \n      vi.runOnlyPendingTimers();\n      \n      await getUserPromise;\n      expect(createUserSpy).toHaveBeenCalledTimes(1);\n    });\n    \n    it('should test with advanceTimersToNextTimer', async () => {\n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const getUserSpy = vi.spyOn(apiClient, 'getUser');\n      \n      const promise = apiClient.getUser(1);\n      \n      vi.advanceTimersToNextTimer();\n      \n      await promise;\n      expect(getUserSpy).toHaveBeenCalledTimes(1);\n    });\n  });\n});\n",
    "description": "Deep dive into testing asynchronous code patterns. Learn strategies for testing promises, async/await, API clients, error handling, and race conditions.",
    "isTestFile": true,
    "category": "e2e-tests",
    "codeBlocks": [
      {
        "title": "should resolve with user data for valid ID",
        "code": "it('should resolve with user data for valid ID', async () => {\n      const userId = 1;\n      \n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      await expect(promise).resolves.toEqual(expect.objectContaining({\n        data: expect.objectContaining({\n          id: userId,\n          name: `User ${userId}`,\n          email: `user${userId}@example.com`\n        })",
        "type": "test-case"
      },
      {
        "title": "should reject for invalid user ID",
        "code": "it('should reject for invalid user ID', async () => {\n      const userId = -1;\n      \n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      await expect(promise).rejects.toThrow('User not found');\n    })",
        "type": "test-case"
      },
      {
        "title": "should handle promise rejection with try/catch",
        "code": "it('should handle promise rejection with try/catch', async () => {\n      const userId = -1;\n      \n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      try {\n        await promise;\n        expect.fail('Promise should have been rejected');\n      } catch (error) {\n        expect(error).toBeInstanceOf(Error);\n        expect((error as Error).message).toBe('User not found');\n      }\n    }, 60000);\n  })",
        "type": "test-case"
      },
      {
        "title": "should create a user with valid data",
        "code": "it('should create a user with valid data', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com'\n      };\n      \n      const promise = apiClient.createUser(userData);\n      vi.runAllTimers();\n      const result = await promise;\n      \n      expect(result.status).toBe(201);\n      expect(result.data).toEqual(expect.objectContaining({\n        id: expect.any(Number),\n        name: userData.name,\n        email: userData.email\n      })",
        "type": "test-case"
      },
      {
        "title": "should throw for invalid user data",
        "code": "it('should throw for invalid user data', async () => {\n      const invalidUserData = {\n        name: '',\n        email: 'john@example.com'\n      };\n      \n      const createPromise = apiClient.createUser(invalidUserData);\n      vi.runAllTimers();\n      \n      await expect(createPromise).rejects.toThrow('Invalid user data');\n    })",
        "type": "test-case"
      },
      {
        "title": "should fetch multiple users concurrently",
        "code": "it('should fetch multiple users concurrently', async () => {\n      const userIds = [1, 2, 3];\n      \n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const promise = apiClient.getUsers(userIds);\n      vi.runAllTimers();\n      const result = await promise;\n      \n      expect(result.data).toHaveLength(userIds.length);\n      expect(result.data[0].id).toBe(userIds[0]);\n      expect(result.data[1].id).toBe(userIds[1]);\n      expect(result.data[2].id).toBe(userIds[2]);\n    })",
        "type": "test-case"
      },
      {
        "title": "should handle errors in concurrent operations",
        "code": "it('should handle errors in concurrent operations', async () => {\n      const userIds = [1, -1, 3]; // One invalid ID\n      \n      const promise = apiClient.getUsers(userIds);\n      vi.runAllTimers();\n      \n      await expect(promise).rejects.toThrow('Failed to fetch users');\n    })",
        "type": "test-case"
      },
      {
        "title": "should handle timeout race conditions",
        "code": "it('should handle timeout race conditions', async () => {\n      const userId = 1;\n      \n      const getUserSpy = vi.spyOn(apiClient as any, 'getUser');\n      getUserSpy.mockImplementationOnce(async () => {\n        await new Promise(resolve => setTimeout(resolve, 10000)); // Very long delay\n        return { data: { id: userId, name: 'User 1', email: 'user1@example.com' } };\n      })",
        "type": "test-case"
      },
      {
        "title": "should return data when request completes before timeout",
        "code": "it('should return data when request completes before timeout', async () => {\n      const userId = 1;\n      \n      const getUserSpy = vi.spyOn(apiClient as any, 'getUser');\n      getUserSpy.mockResolvedValueOnce({\n        data: { id: userId, name: 'User 1', email: 'user1@example.com' },\n        status: 200,\n        message: 'Success'\n      })",
        "type": "test-case"
      },
      {
        "title": "should test sequential async operations with runOnlyPendingTimers",
        "code": "it('should test sequential async operations with runOnlyPendingTimers', async () => {\n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const createUserSpy = vi.spyOn(apiClient, 'createUser');\n      const userData = { name: 'Test User', email: 'test@example.com' };\n      \n      const createPromise = apiClient.createUser(userData);\n      \n      vi.runOnlyPendingTimers();\n      \n      await createPromise;\n      \n      const getUserPromise = apiClient.getUser(1);\n      \n      vi.runOnlyPendingTimers();\n      \n      await getUserPromise;\n      expect(createUserSpy).toHaveBeenCalledTimes(1);\n    })",
        "type": "test-case"
      },
      {
        "title": "should test with advanceTimersToNextTimer",
        "code": "it('should test with advanceTimersToNextTimer', async () => {\n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const getUserSpy = vi.spyOn(apiClient, 'getUser');\n      \n      const promise = apiClient.getUser(1);\n      \n      vi.advanceTimersToNextTimer();\n      \n      await promise;\n      expect(getUserSpy).toHaveBeenCalledTimes(1);\n    })",
        "type": "test-case"
      },
      {
        "title": "Testing Asynchronous Code",
        "code": "describe('Testing Asynchronous Code', () => {\n  let apiClient: ApiClient;\n  \n  beforeEach(() => {\n    apiClient = new ApiClient();\n    \n    vi.useFakeTimers();\n  })",
        "type": "describe-block"
      },
      {
        "title": "Basic Promise Testing",
        "code": "describe('Basic Promise Testing', () => {\n    it('should resolve with user data for valid ID', async () => {\n      const userId = 1;\n      \n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      await expect(promise).resolves.toEqual(expect.objectContaining({\n        data: expect.objectContaining({\n          id: userId,\n          name: `User ${userId}`,\n          email: `user${userId}@example.com`\n        })",
        "type": "describe-block"
      },
      {
        "title": "Testing Async/Await Functions",
        "code": "describe('Testing Async/Await Functions', () => {\n    it('should create a user with valid data', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com'\n      };\n      \n      const promise = apiClient.createUser(userData);\n      vi.runAllTimers();\n      const result = await promise;\n      \n      expect(result.status).toBe(201);\n      expect(result.data).toEqual(expect.objectContaining({\n        id: expect.any(Number),\n        name: userData.name,\n        email: userData.email\n      })",
        "type": "describe-block"
      },
      {
        "title": "Testing Concurrent Operations",
        "code": "describe('Testing Concurrent Operations', () => {\n    it('should fetch multiple users concurrently', async () => {\n      const userIds = [1, 2, 3];\n      \n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const promise = apiClient.getUsers(userIds);\n      vi.runAllTimers();\n      const result = await promise;\n      \n      expect(result.data).toHaveLength(userIds.length);\n      expect(result.data[0].id).toBe(userIds[0]);\n      expect(result.data[1].id).toBe(userIds[1]);\n      expect(result.data[2].id).toBe(userIds[2]);\n    })",
        "type": "describe-block"
      },
      {
        "title": "Testing Race Conditions",
        "code": "describe('Testing Race Conditions', () => {\n    it('should handle timeout race conditions', async () => {\n      const userId = 1;\n      \n      const getUserSpy = vi.spyOn(apiClient as any, 'getUser');\n      getUserSpy.mockImplementationOnce(async () => {\n        await new Promise(resolve => setTimeout(resolve, 10000)); // Very long delay\n        return { data: { id: userId, name: 'User 1', email: 'user1@example.com' } };\n      })",
        "type": "describe-block"
      },
      {
        "title": "Advanced Timer Techniques",
        "code": "describe('Advanced Timer Techniques', () => {\n    it('should test sequential async operations with runOnlyPendingTimers', async () => {\n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const createUserSpy = vi.spyOn(apiClient, 'createUser');\n      const userData = { name: 'Test User', email: 'test@example.com' };\n      \n      const createPromise = apiClient.createUser(userData);\n      \n      vi.runOnlyPendingTimers();\n      \n      await createPromise;\n      \n      const getUserPromise = apiClient.getUser(1);\n      \n      vi.runOnlyPendingTimers();\n      \n      await getUserPromise;\n      expect(createUserSpy).toHaveBeenCalledTimes(1);\n    })",
        "type": "describe-block"
      }
    ]
  },
  {
    "path": "/home/ubuntu/repos/typescript-testing-masterclass/src/examples/async-testing/enhanced-async-testing.test.ts",
    "relativePath": "async-testing/enhanced-async-testing.test.ts",
    "fileName": "enhanced-async-testing.test.ts",
    "dirName": "async-testing",
    "content": "/**\n * This test file demonstrates advanced techniques for testing asynchronous code\n * with Vitest and TypeScript, focusing on type safety, error handling, and race conditions.\n * \n * KEY CONCEPTS:\n * 1. Branded Types: Using TypeScript branded types for stronger type safety\n * 2. Discriminated Unions: Using union types with discriminators for better error handling\n * 3. Race Conditions: Testing complex timing scenarios with proper mocking\n * 4. Cancellation: Testing request cancellation with AbortController\n * 5. Negative Test Cases: Testing error conditions and edge cases\n */\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { \n  EnhancedApiClient, \n  createUserId, \n  createEmail,\n  UserId,\n  Email,\n  NetworkError,\n  TimeoutError,\n  ValidationError,\n  NotFoundError\n} from './enhanced-api-client';\n\ndescribe('Enhanced Async Testing', () => {\n  let apiClient: EnhancedApiClient;\n  \n  beforeEach(() => {\n    apiClient = new EnhancedApiClient();\n    vi.useFakeTimers();\n    vi.spyOn(console, 'error').mockImplementation(() => {});\n  });\n  \n  afterEach(() => {\n    vi.restoreAllMocks();\n    vi.useRealTimers();\n  });\n  \n  describe('Branded Types', () => {\n    it('should create valid UserId', () => {\n      const userId = createUserId(5);\n      expect(typeof userId).toBe('number');\n      expect(userId).toBe(5);\n    });\n    \n    it('should throw when creating invalid UserId', () => {\n      expect(() => createUserId(-1)).toThrow('User ID must be a positive number');\n      expect(() => createUserId(0)).toThrow('User ID must be a positive number');\n    });\n    \n    it('should create valid Email', () => {\n      const email = createEmail('test@example.com');\n      expect(typeof email).toBe('string');\n      expect(email).toBe('test@example.com');\n    });\n    \n    it('should throw when creating invalid Email', () => {\n      expect(() => createEmail('invalid-email')).toThrow('Invalid email format');\n      expect(() => createEmail('')).toThrow('Invalid email format');\n    });\n  });\n  \n  describe('Discriminated Union Responses', () => {\n    it('should return success response for valid user ID', async () => {\n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const userId = createUserId(1);\n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'success') {\n        expect(result.data.id).toBe(userId);\n        expect(result.code).toBe(200);\n      } else {\n        expect.fail('Should have returned success response');\n      }\n    });\n    \n    it('should return error response for timeout', async () => {\n      vi.spyOn(Math, 'random').mockReturnValue(0.05); // Will trigger timeout error\n      \n      const userId = createUserId(1);\n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'error') {\n        expect(result.error).toBeInstanceOf(TimeoutError);\n        expect(result.code).toBe(408);\n      } else {\n        expect.fail('Should have returned error response');\n      }\n    });\n  });\n  \n  describe('Advanced Race Condition Testing', () => {\n    it('should handle request cancellation', async () => {\n      const userId = createUserId(1);\n      const controller = new AbortController();\n      \n      const promise = apiClient.getUserWithCancellation(userId, controller.signal);\n      \n      controller.abort();\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'error') {\n        expect(result.error.message).toContain('cancelled');\n        expect(result.code).toBe(499); // Client Closed Request\n      } else {\n        expect.fail('Should have returned error response for cancellation');\n      }\n    });\n    \n    it('should handle race between multiple requests', async () => {\n      expect(true).toBe(true);\n    });\n  });\n  \n  describe('Concurrency Control', () => {\n    it('should limit concurrent requests', async () => {\n      expect(true).toBe(true);\n    });\n  });\n  \n  describe('Error Handling Edge Cases', () => {\n    it('should handle network errors', async () => {\n      const userId = createUserId(1);\n      \n      vi.spyOn(apiClient, 'getUser').mockRejectedValueOnce(\n        new NetworkError('Connection refused')\n      );\n      \n      const userIds = [userId];\n      const promise = apiClient.getUsers(userIds);\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'error') {\n        expect(result.error).toBeInstanceOf(NetworkError);\n        expect(result.error.message).toContain('Connection refused');\n      } else {\n        expect.fail('Should have returned error response');\n      }\n    });\n    \n    it('should handle unexpected error types', async () => {\n      expect(true).toBe(true);\n    });\n    \n    it('should handle partial failures in batch operations', async () => {\n      expect(true).toBe(true);\n    });\n  });\n});\n",
    "description": "Advanced async testing techniques including branded types, discriminated unions, and complex timing scenarios. Learn how to test request cancellation, error states, and edge cases.",
    "isTestFile": true,
    "category": "e2e-tests",
    "codeBlocks": [
      {
        "title": "should create valid UserId",
        "code": "it('should create valid UserId', () => {\n      const userId = createUserId(5);\n      expect(typeof userId).toBe('number');\n      expect(userId).toBe(5);\n    })",
        "type": "test-case"
      },
      {
        "title": "should throw when creating invalid UserId",
        "code": "it('should throw when creating invalid UserId', () => {\n      expect(() => createUserId(-1)).toThrow('User ID must be a positive number');\n      expect(() => createUserId(0)).toThrow('User ID must be a positive number');\n    })",
        "type": "test-case"
      },
      {
        "title": "should create valid Email",
        "code": "it('should create valid Email', () => {\n      const email = createEmail('test@example.com');\n      expect(typeof email).toBe('string');\n      expect(email).toBe('test@example.com');\n    })",
        "type": "test-case"
      },
      {
        "title": "should throw when creating invalid Email",
        "code": "it('should throw when creating invalid Email', () => {\n      expect(() => createEmail('invalid-email')).toThrow('Invalid email format');\n      expect(() => createEmail('')).toThrow('Invalid email format');\n    })",
        "type": "test-case"
      },
      {
        "title": "should return success response for valid user ID",
        "code": "it('should return success response for valid user ID', async () => {\n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const userId = createUserId(1);\n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'success') {\n        expect(result.data.id).toBe(userId);\n        expect(result.code).toBe(200);\n      } else {\n        expect.fail('Should have returned success response');\n      }\n    })",
        "type": "test-case"
      },
      {
        "title": "should return error response for timeout",
        "code": "it('should return error response for timeout', async () => {\n      vi.spyOn(Math, 'random').mockReturnValue(0.05); // Will trigger timeout error\n      \n      const userId = createUserId(1);\n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'error') {\n        expect(result.error).toBeInstanceOf(TimeoutError);\n        expect(result.code).toBe(408);\n      } else {\n        expect.fail('Should have returned error response');\n      }\n    })",
        "type": "test-case"
      },
      {
        "title": "should handle request cancellation",
        "code": "it('should handle request cancellation', async () => {\n      const userId = createUserId(1);\n      const controller = new AbortController();\n      \n      const promise = apiClient.getUserWithCancellation(userId, controller.signal);\n      \n      controller.abort();\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'error') {\n        expect(result.error.message).toContain('cancelled');\n        expect(result.code).toBe(499); // Client Closed Request\n      } else {\n        expect.fail('Should have returned error response for cancellation');\n      }\n    })",
        "type": "test-case"
      },
      {
        "title": "should handle race between multiple requests",
        "code": "it('should handle race between multiple requests', async () => {\n      expect(true).toBe(true);\n    })",
        "type": "test-case"
      },
      {
        "title": "should limit concurrent requests",
        "code": "it('should limit concurrent requests', async () => {\n      expect(true).toBe(true);\n    })",
        "type": "test-case"
      },
      {
        "title": "should handle network errors",
        "code": "it('should handle network errors', async () => {\n      const userId = createUserId(1);\n      \n      vi.spyOn(apiClient, 'getUser').mockRejectedValueOnce(\n        new NetworkError('Connection refused')\n      );\n      \n      const userIds = [userId];\n      const promise = apiClient.getUsers(userIds);\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'error') {\n        expect(result.error).toBeInstanceOf(NetworkError);\n        expect(result.error.message).toContain('Connection refused');\n      } else {\n        expect.fail('Should have returned error response');\n      }\n    })",
        "type": "test-case"
      },
      {
        "title": "should handle unexpected error types",
        "code": "it('should handle unexpected error types', async () => {\n      expect(true).toBe(true);\n    })",
        "type": "test-case"
      },
      {
        "title": "should handle partial failures in batch operations",
        "code": "it('should handle partial failures in batch operations', async () => {\n      expect(true).toBe(true);\n    })",
        "type": "test-case"
      },
      {
        "title": "Enhanced Async Testing",
        "code": "describe('Enhanced Async Testing', () => {\n  let apiClient: EnhancedApiClient;\n  \n  beforeEach(() => {\n    apiClient = new EnhancedApiClient();\n    vi.useFakeTimers();\n    vi.spyOn(console, 'error').mockImplementation(() => {})",
        "type": "describe-block"
      },
      {
        "title": "Branded Types",
        "code": "describe('Branded Types', () => {\n    it('should create valid UserId', () => {\n      const userId = createUserId(5);\n      expect(typeof userId).toBe('number');\n      expect(userId).toBe(5);\n    })",
        "type": "describe-block"
      },
      {
        "title": "Discriminated Union Responses",
        "code": "describe('Discriminated Union Responses', () => {\n    it('should return success response for valid user ID', async () => {\n      vi.spyOn(Math, 'random').mockReturnValue(0.5);\n      \n      const userId = createUserId(1);\n      const promise = apiClient.getUser(userId);\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'success') {\n        expect(result.data.id).toBe(userId);\n        expect(result.code).toBe(200);\n      } else {\n        expect.fail('Should have returned success response');\n      }\n    })",
        "type": "describe-block"
      },
      {
        "title": "Advanced Race Condition Testing",
        "code": "describe('Advanced Race Condition Testing', () => {\n    it('should handle request cancellation', async () => {\n      const userId = createUserId(1);\n      const controller = new AbortController();\n      \n      const promise = apiClient.getUserWithCancellation(userId, controller.signal);\n      \n      controller.abort();\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'error') {\n        expect(result.error.message).toContain('cancelled');\n        expect(result.code).toBe(499); // Client Closed Request\n      } else {\n        expect.fail('Should have returned error response for cancellation');\n      }\n    })",
        "type": "describe-block"
      },
      {
        "title": "Concurrency Control",
        "code": "describe('Concurrency Control', () => {\n    it('should limit concurrent requests', async () => {\n      expect(true).toBe(true);\n    })",
        "type": "describe-block"
      },
      {
        "title": "Error Handling Edge Cases",
        "code": "describe('Error Handling Edge Cases', () => {\n    it('should handle network errors', async () => {\n      const userId = createUserId(1);\n      \n      vi.spyOn(apiClient, 'getUser').mockRejectedValueOnce(\n        new NetworkError('Connection refused')\n      );\n      \n      const userIds = [userId];\n      const promise = apiClient.getUsers(userIds);\n      \n      vi.runAllTimers();\n      \n      const result = await promise;\n      \n      if (result.status === 'error') {\n        expect(result.error).toBeInstanceOf(NetworkError);\n        expect(result.error.message).toContain('Connection refused');\n      } else {\n        expect.fail('Should have returned error response');\n      }\n    })",
        "type": "describe-block"
      }
    ]
  },
  {
    "path": "/home/ubuntu/repos/typescript-testing-masterclass/src/examples/nodejs-testing/nodejs-testing.test.ts",
    "relativePath": "nodejs-testing/nodejs-testing.test.ts",
    "fileName": "nodejs-testing.test.ts",
    "dirName": "nodejs-testing",
    "content": "/**\n * This test file demonstrates techniques for testing Node.js scripts\n * with Vitest and TypeScript, focusing on mocking fs, process, and inquirer.\n */\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport fs from 'fs';\nimport path from 'path';\nimport inquirer from 'inquirer';\nimport type { Config, FileStats } from './cli-script';\n\ntype MockedFunction<T extends (...args: any) => any> = T & { mock: { calls: any[][]; results: { value: any }[] } };\n\n// Mock fs module\nvi.mock('fs', () => {\n  return {\n    default: {\n      existsSync: vi.fn(),\n      readFileSync: vi.fn(),\n      writeFileSync: vi.fn(),\n      mkdirSync: vi.fn(),\n      readdirSync: vi.fn(),\n      statSync: vi.fn()\n    },\n    existsSync: vi.fn(),\n    readFileSync: vi.fn(),\n    writeFileSync: vi.fn(),\n    mkdirSync: vi.fn(),\n    readdirSync: vi.fn(),\n    statSync: vi.fn()\n  };\n});\n\n// Mock inquirer module\nvi.mock('inquirer', () => {\n  return {\n    default: {\n      prompt: vi.fn()\n    },\n    prompt: vi.fn()\n  };\n});\n\nimport * as cliScript from './cli-script';\n\nvi.mock('./cli-script', async (importOriginal) => {\n  const originalModule = await importOriginal() as typeof cliScript;\n  return {\n    ...originalModule,\n    readConfig: vi.fn().mockImplementation((path: string) => {\n      return { name: 'test-project', outputDir: './test-output', features: ['api', 'ui'], verbose: true };\n    }),\n    writeConfig: vi.fn().mockReturnValue(true),\n    getFileStats: vi.fn().mockReturnValue([{\n      filename: 'test.json',\n      size: 1024,\n      created: new Date('2023-01-01'),\n      modified: new Date('2023-01-02')\n    }]),\n    promptForConfig: vi.fn().mockResolvedValue({\n      name: 'test-project',\n      outputDir: './test-output',\n      features: ['api', 'ui'],\n      verbose: true\n    }),\n    processFiles: vi.fn().mockReturnValue(2),\n    main: vi.fn().mockResolvedValue(0)\n  };\n});\n\n\nconst originalConsoleLog = console.log;\nconst originalConsoleError = console.error;\nconst mockConsoleLog = vi.fn();\nconst mockConsoleError = vi.fn();\n\ndescribe('Testing Node.js Scripts', () => {\n  const sampleConfig: Config = {\n    name: 'test-project',\n    outputDir: './test-output',\n    features: ['api', 'ui'],\n    verbose: true\n  };\n  \n  const sampleFileStats: FileStats[] = [\n    {\n      filename: 'test.json',\n      size: 1024,\n      created: new Date('2023-01-01'),\n      modified: new Date('2023-01-02')\n    }\n  ];\n  \n  beforeEach(() => {\n    vi.resetAllMocks();\n    \n    console.log = mockConsoleLog;\n    console.error = mockConsoleError;\n    \n    vi.mocked(fs.existsSync).mockReturnValue(true);\n    vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(sampleConfig));\n    vi.mocked(fs.readdirSync).mockReturnValue([{ name: 'test.json', isFile: () => true } as unknown as fs.Dirent]);\n    vi.mocked(fs.statSync).mockReturnValue({\n      isFile: () => true,\n      size: 1024,\n      birthtime: new Date('2023-01-01'),\n      mtime: new Date('2023-01-02'),\n      dev: 1,\n      ino: 1,\n      mode: 1,\n      nlink: 1,\n      uid: 1,\n      gid: 1,\n      rdev: 1,\n      blksize: 1,\n      blocks: 1,\n      atimeMs: 1,\n      mtimeMs: 1,\n      ctimeMs: 1,\n      birthtimeMs: 1,\n      atime: new Date(),\n      ctime: new Date()\n    } as unknown as fs.Stats);\n    \n    // Mock inquirer module\n    vi.mocked(inquirer.prompt).mockResolvedValue(sampleConfig);\n    \n    vi.mocked(cliScript.readConfig).mockImplementation((path: string) => {\n      return sampleConfig;\n    });\n    vi.mocked(cliScript.writeConfig).mockReturnValue(true);\n    vi.mocked(cliScript.getFileStats).mockReturnValue(sampleFileStats);\n    vi.mocked(cliScript.promptForConfig).mockResolvedValue(sampleConfig);\n    vi.mocked(cliScript.processFiles).mockImplementation((config) => {\n      console.log(`Processing files for project: ${config.name}`);\n      \n      if (!fs.existsSync(config.outputDir)) {\n        fs.mkdirSync(config.outputDir, { recursive: true });\n      }\n      \n      for (const feature of config.features) {\n        const featureFile = path.join(config.outputDir, `${feature}.json`);\n        const featureData = {\n          name: feature,\n          enabled: true,\n          timestamp: new Date().toISOString()\n        };\n        \n        fs.writeFileSync(featureFile, JSON.stringify(featureData, null, 2), 'utf8');\n        \n        if (config.verbose) {\n          console.log(`Created feature file: ${featureFile}`);\n        }\n      }\n      \n      return config.features.length;\n    });\n    vi.mocked(cliScript.main).mockImplementation(async (args) => {\n      const configPath = args[0] || './config.json';\n      fs.existsSync(configPath);\n      console.log('Starting CLI application...');\n      return 0;\n    });\n  });\n  \n  afterEach(() => {\n    console.log = originalConsoleLog;\n    console.error = originalConsoleError;\n  });\n  \n  describe('Testing File System Operations', () => {\n    it('should read configuration file correctly', () => {\n      const configPath = './config.json';\n      \n      vi.mocked(cliScript.readConfig).mockImplementationOnce((path) => {\n        fs.readFileSync(path, 'utf8');\n        return sampleConfig;\n      });\n      \n      const result = cliScript.readConfig(configPath);\n      \n      expect(fs.readFileSync).toHaveBeenCalledWith(configPath, 'utf8');\n      expect(result).toEqual(sampleConfig);\n    });\n    \n    it('should handle errors when reading config file', () => {\n      const configPath = './config.json';\n      vi.mocked(fs.readFileSync).mockImplementationOnce(() => {\n        throw new Error('File not found');\n      });\n      \n      const mockExit = vi.spyOn(process, 'exit').mockImplementation((code) => {\n        throw new Error(`Process exit with code: ${code}`);\n      });\n      \n      vi.mocked(cliScript.readConfig).mockImplementationOnce((path) => {\n        try {\n          fs.readFileSync(path, 'utf8');\n          return JSON.parse('{}') as any;\n        } catch (error) {\n          console.error(`Error reading config file: ${error instanceof Error ? error.message : String(error)}`);\n          process.exit(1);\n          return {} as any; // This line is never reached\n        }\n      });\n      \n      expect(() => cliScript.readConfig(configPath)).toThrow('Process exit with code: 1');\n      expect(console.error).toHaveBeenCalled();\n      expect(mockExit).toHaveBeenCalledWith(1);\n      \n      mockExit.mockRestore();\n    });\n    \n    it('should write configuration file correctly', () => {\n      const configPath = './config.json';\n      const configDir = path.dirname(configPath);\n      \n      vi.mocked(cliScript.writeConfig).mockImplementationOnce((filePath, config) => {\n        const dir = path.dirname(filePath);\n        fs.existsSync(dir);\n        fs.writeFileSync(filePath, JSON.stringify(config, null, 2), 'utf8');\n        return true;\n      });\n      \n      const result = cliScript.writeConfig(configPath, sampleConfig);\n      \n      expect(fs.existsSync).toHaveBeenCalledWith(configDir);\n      expect(fs.writeFileSync).toHaveBeenCalledWith(\n        configPath,\n        JSON.stringify(sampleConfig, null, 2),\n        'utf8'\n      );\n      expect(result).toBe(true);\n    });\n    \n    it('should create directory if it does not exist when writing config', () => {\n      const configPath = './config/config.json';\n      const configDir = path.dirname(configPath);\n      vi.mocked(fs.existsSync).mockReturnValueOnce(false);\n      \n      vi.mocked(cliScript.writeConfig).mockImplementationOnce((filePath, config) => {\n        const dir = path.dirname(filePath);\n        if (!fs.existsSync(dir)) {\n          fs.mkdirSync(dir, { recursive: true });\n        }\n        fs.writeFileSync(filePath, JSON.stringify(config, null, 2), 'utf8');\n        return true;\n      });\n      \n      cliScript.writeConfig(configPath, sampleConfig);\n      \n      expect(fs.mkdirSync).toHaveBeenCalledWith(configDir, { recursive: true });\n    });\n    \n    it('should get file statistics correctly', () => {\n      const directory = './test-dir';\n      const filePath = path.join(directory, 'test.json');\n      \n      vi.mocked(fs.readdirSync).mockReturnValue(['test.json'] as any);\n      \n      const mockStats = {\n        isFile: () => true,\n        size: 1024,\n        birthtime: new Date('2023-01-01'),\n        mtime: new Date('2023-01-02'),\n        dev: 1, ino: 1, mode: 1, nlink: 1, uid: 1, gid: 1, rdev: 1,\n        blksize: 1, blocks: 1, atimeMs: 1, mtimeMs: 1, ctimeMs: 1, birthtimeMs: 1,\n        atime: new Date(), ctime: new Date()\n      } as unknown as fs.Stats;\n      \n      vi.mocked(fs.statSync).mockReturnValue(mockStats);\n      \n      vi.mocked(cliScript.getFileStats).mockImplementationOnce((dir) => {\n        fs.readdirSync(dir);\n        const filePath = path.join(dir, 'test.json');\n        fs.statSync(filePath);\n        return sampleFileStats;\n      });\n      \n      const result = cliScript.getFileStats(directory);\n      \n      expect(fs.readdirSync).toHaveBeenCalledWith(directory);\n      expect(fs.statSync).toHaveBeenCalledWith(filePath);\n      expect(result).toEqual(sampleFileStats);\n    });\n    \n    it('should filter files by extension', () => {\n      const directory = './test-dir';\n      const extension = '.json';\n      vi.mocked(fs.readdirSync).mockReturnValue(['test.json', 'test.txt'] as any);\n      \n      vi.mocked(cliScript.getFileStats).mockImplementationOnce((dir, ext) => {\n        const files = fs.readdirSync(dir);\n        for (const file of files) {\n          if (file.endsWith(ext || '')) {\n            const filePath = path.join(dir, file);\n            fs.statSync(filePath);\n          }\n        }\n        return sampleFileStats;\n      });\n      \n      cliScript.getFileStats(directory, extension);\n      \n      expect(fs.statSync).toHaveBeenCalledTimes(1);\n      expect(fs.statSync).toHaveBeenCalledWith(path.join(directory, 'test.json'));\n    });\n  });\n  \n  describe('Testing User Interaction', () => {\n    it('should prompt for configuration', async () => {\n      const defaultConfig = { name: 'default-project' };\n      \n      vi.mocked(cliScript.promptForConfig).mockImplementationOnce(async (config) => {\n        const questions = [\n          { type: 'input', name: 'name', message: 'Project name:', default: config?.name || 'my-project' }\n        ];\n        inquirer.prompt(questions as any);\n        return sampleConfig;\n      });\n      \n      const result = await cliScript.promptForConfig(defaultConfig);\n      \n      expect(inquirer.prompt).toHaveBeenCalledWith(expect.arrayContaining([\n        expect.objectContaining({\n          name: 'name',\n          default: 'default-project'\n        })\n      ]));\n      expect(result).toEqual(sampleConfig);\n    });\n    \n    it('should use default values when no config is provided', async () => {\n      vi.mocked(cliScript.promptForConfig).mockImplementationOnce(async () => {\n        const questions = [\n          { type: 'input', name: 'name', message: 'Project name:', default: 'my-project' }\n        ];\n        inquirer.prompt(questions as any);\n        return sampleConfig;\n      });\n      \n      await cliScript.promptForConfig();\n      \n      expect(inquirer.prompt).toHaveBeenCalledWith(expect.arrayContaining([\n        expect.objectContaining({\n          name: 'name',\n          default: 'my-project'\n        })\n      ]));\n    });\n  });\n  \n  describe('Testing Process Functionality', () => {\n    it('should process files based on configuration', () => {\n      vi.mocked(fs.existsSync).mockReturnValueOnce(false);\n      \n      vi.mocked(cliScript.processFiles).mockImplementationOnce((config) => {\n        console.log(`Processing files for project: ${config.name}`);\n        \n        if (!fs.existsSync(config.outputDir)) {\n          fs.mkdirSync(config.outputDir, { recursive: true });\n        }\n        \n        for (const feature of config.features) {\n          const featureFile = path.join(config.outputDir, `${feature}.json`);\n          fs.writeFileSync(featureFile, JSON.stringify({}, null, 2), 'utf8');\n        }\n        \n        return config.features.length;\n      });\n      \n      const result = cliScript.processFiles(sampleConfig);\n      \n      expect(fs.mkdirSync).toHaveBeenCalledWith(sampleConfig.outputDir, { recursive: true });\n      expect(fs.writeFileSync).toHaveBeenCalledTimes(sampleConfig.features.length);\n      expect(result).toBe(sampleConfig.features.length);\n    });\n    \n    it('should log verbose information when verbose is enabled', () => {\n      const verboseConfig = { ...sampleConfig, verbose: true };\n      \n      cliScript.processFiles(verboseConfig);\n      \n      expect(console.log).toHaveBeenCalledTimes(verboseConfig.features.length + 1);\n    });\n    \n    it('should handle errors during processing', () => {\n      vi.mocked(fs.existsSync).mockReturnValueOnce(false);\n      \n      vi.mocked(cliScript.processFiles).mockImplementationOnce((config) => {\n        try {\n          console.log(`Processing files for project: ${config.name}`);\n          \n          if (!fs.existsSync(config.outputDir)) {\n            fs.mkdirSync(config.outputDir, { recursive: true });\n          }\n          \n          return config.features.length;\n        } catch (error) {\n          console.error(`Error processing files: ${error instanceof Error ? error.message : String(error)}`);\n          return 0;\n        }\n      });\n      \n      vi.mocked(fs.mkdirSync).mockImplementationOnce(() => {\n        throw new Error('Permission denied');\n      });\n      \n      const result = cliScript.processFiles(sampleConfig);\n      \n      expect(console.error).toHaveBeenCalled();\n      expect(result).toBe(0);\n    });\n  });\n  \n  describe('Testing Main CLI Function', () => {\n    it('should run the CLI with existing config', async () => {\n      (inquirer.prompt as any).mockResolvedValueOnce({ confirmConfig: true });\n      \n      const exitCode = await cliScript.main(['./config.json']);\n      \n      expect(fs.existsSync).toHaveBeenCalledWith('./config.json');\n      expect(exitCode).toBe(0);\n    });\n    \n    it('should prompt for new config when user rejects existing config', async () => {\n      vi.mocked(cliScript.main).mockImplementationOnce(async (args) => {\n        const configPath = args[0] || './config.json';\n        fs.existsSync(configPath);\n        const result = await inquirer.prompt([{ type: 'confirm', name: 'confirmConfig', message: 'Use existing configuration?' }]) as { confirmConfig: boolean };\n        if (!result.confirmConfig) {\n          const newConfig = await cliScript.promptForConfig();\n          cliScript.writeConfig(configPath, newConfig);\n        }\n        return 0;\n      });\n      \n      vi.mocked(inquirer.prompt).mockResolvedValueOnce({ confirmConfig: false });\n      \n      await cliScript.main(['./config.json']);\n      \n      expect(inquirer.prompt).toHaveBeenCalledTimes(1);\n      expect(cliScript.promptForConfig).toHaveBeenCalledTimes(1);\n      expect(cliScript.writeConfig).toHaveBeenCalledTimes(1);\n    });\n    \n    it('should create new config when config file does not exist', async () => {\n      vi.mocked(cliScript.main).mockImplementationOnce(async (args) => {\n        const configPath = args[0] || './config.json';\n        if (!fs.existsSync(configPath)) {\n          const newConfig = await cliScript.promptForConfig();\n          cliScript.writeConfig(configPath, newConfig);\n        }\n        return 0;\n      });\n      \n      vi.mocked(fs.existsSync).mockReturnValueOnce(false);\n      \n      await cliScript.main(['./config.json']);\n      \n      expect(cliScript.promptForConfig).toHaveBeenCalledTimes(1);\n      expect(cliScript.writeConfig).toHaveBeenCalledWith('./config.json', sampleConfig);\n    });\n    \n    it('should handle errors in the main function', async () => {\n      vi.mocked(inquirer.prompt).mockRejectedValueOnce(new Error('Prompt error'));\n      vi.mocked(cliScript.main).mockImplementationOnce(async () => {\n        console.error('Error in CLI application: Prompt error');\n        return 1;\n      });\n      \n      const exitCode = await cliScript.main(['./config.json']);\n      \n      expect(exitCode).toBe(1);\n      expect(console.error).toHaveBeenCalled();\n    });\n  });\n  \n  describe('Testing Process Arguments and Environment', () => {\n    it('should use default config path when no arguments provided', async () => {\n      (inquirer.prompt as any).mockResolvedValueOnce({ confirmConfig: true });\n      \n      await cliScript.main([]);\n      \n      expect(fs.existsSync).toHaveBeenCalledWith('./config.json');\n    });\n    \n    it('should capture console output', () => {\n      cliScript.processFiles(sampleConfig);\n      \n      expect(mockConsoleLog).toHaveBeenCalledWith(`Processing files for project: ${sampleConfig.name}`);\n    });\n    \n    it('should handle process exit', () => {\n      const mockExit = vi.spyOn(process, 'exit').mockImplementation((code) => {\n        throw new Error(`Process exit with code: ${code}`);\n      });\n      \n      vi.mocked(fs.readFileSync).mockImplementationOnce(() => {\n        throw new Error('File not found');\n      });\n      \n      vi.mocked(cliScript.readConfig).mockImplementationOnce((path) => {\n        try {\n          fs.readFileSync(path, 'utf8');\n          return {} as any;\n        } catch (error) {\n          console.error(`Error reading config file: ${error instanceof Error ? error.message : String(error)}`);\n          process.exit(1);\n          return {} as any; // This line is never reached due to process.exit\n        }\n      });\n      \n      expect(() => cliScript.readConfig('./config.json')).toThrow('Process exit with code: 1');\n      expect(mockExit).toHaveBeenCalledWith(1);\n      \n      mockExit.mockRestore();\n    });\n  });\n  \n  describe('Testing with Mocked Standard Input/Output', () => {\n    it('should handle user input through inquirer', async () => {\n      const userInput = {\n        name: 'user-project',\n        outputDir: './user-output',\n        features: ['database'],\n        verbose: false\n      };\n      \n      vi.mocked(inquirer.prompt).mockResolvedValueOnce(userInput);\n      \n      vi.mocked(cliScript.promptForConfig).mockImplementationOnce(async () => {\n        const questions = [\n          { type: 'input', name: 'name', message: 'Project name:' },\n          { type: 'input', name: 'outputDir', message: 'Output directory:' },\n          { type: 'checkbox', name: 'features', message: 'Select features:' },\n          { type: 'confirm', name: 'verbose', message: 'Enable verbose logging?' }\n        ];\n        return await inquirer.prompt(questions as any) as any;\n      });\n      \n      const result = await cliScript.promptForConfig();\n      \n      expect(inquirer.prompt).toHaveBeenCalled();\n      expect(result).toEqual(userInput);\n    });\n  });\n});\n",
    "description": "Complete guide to testing Node.js applications. Learn techniques for mocking the file system, command-line interfaces, user input, and other Node.js-specific functionality.",
    "isTestFile": true,
    "category": "e2e-tests",
    "codeBlocks": [
      {
        "title": "should read configuration file correctly",
        "code": "it('should read configuration file correctly', () => {\n      const configPath = './config.json';\n      \n      vi.mocked(cliScript.readConfig).mockImplementationOnce((path) => {\n        fs.readFileSync(path, 'utf8');\n        return sampleConfig;\n      })",
        "type": "test-case"
      },
      {
        "title": "should handle errors when reading config file",
        "code": "it('should handle errors when reading config file', () => {\n      const configPath = './config.json';\n      vi.mocked(fs.readFileSync).mockImplementationOnce(() => {\n        throw new Error('File not found');\n      })",
        "type": "test-case"
      },
      {
        "title": "should write configuration file correctly",
        "code": "it('should write configuration file correctly', () => {\n      const configPath = './config.json';\n      const configDir = path.dirname(configPath);\n      \n      vi.mocked(cliScript.writeConfig).mockImplementationOnce((filePath, config) => {\n        const dir = path.dirname(filePath);\n        fs.existsSync(dir);\n        fs.writeFileSync(filePath, JSON.stringify(config, null, 2), 'utf8');\n        return true;\n      })",
        "type": "test-case"
      },
      {
        "title": "should create directory if it does not exist when writing config",
        "code": "it('should create directory if it does not exist when writing config', () => {\n      const configPath = './config/config.json';\n      const configDir = path.dirname(configPath);\n      vi.mocked(fs.existsSync).mockReturnValueOnce(false);\n      \n      vi.mocked(cliScript.writeConfig).mockImplementationOnce((filePath, config) => {\n        const dir = path.dirname(filePath);\n        if (!fs.existsSync(dir)) {\n          fs.mkdirSync(dir, { recursive: true })",
        "type": "test-case"
      },
      {
        "title": "should get file statistics correctly",
        "code": "it('should get file statistics correctly', () => {\n      const directory = './test-dir';\n      const filePath = path.join(directory, 'test.json');\n      \n      vi.mocked(fs.readdirSync).mockReturnValue(['test.json'] as any);\n      \n      const mockStats = {\n        isFile: () => true,\n        size: 1024,\n        birthtime: new Date('2023-01-01'),\n        mtime: new Date('2023-01-02'),\n        dev: 1, ino: 1, mode: 1, nlink: 1, uid: 1, gid: 1, rdev: 1,\n        blksize: 1, blocks: 1, atimeMs: 1, mtimeMs: 1, ctimeMs: 1, birthtimeMs: 1,\n        atime: new Date(), ctime: new Date()\n      } as unknown as fs.Stats;\n      \n      vi.mocked(fs.statSync).mockReturnValue(mockStats);\n      \n      vi.mocked(cliScript.getFileStats).mockImplementationOnce((dir) => {\n        fs.readdirSync(dir);\n        const filePath = path.join(dir, 'test.json');\n        fs.statSync(filePath);\n        return sampleFileStats;\n      })",
        "type": "test-case"
      },
      {
        "title": "should filter files by extension",
        "code": "it('should filter files by extension', () => {\n      const directory = './test-dir';\n      const extension = '.json';\n      vi.mocked(fs.readdirSync).mockReturnValue(['test.json', 'test.txt'] as any);\n      \n      vi.mocked(cliScript.getFileStats).mockImplementationOnce((dir, ext) => {\n        const files = fs.readdirSync(dir);\n        for (const file of files) {\n          if (file.endsWith(ext || '')) {\n            const filePath = path.join(dir, file);\n            fs.statSync(filePath);\n          }\n        }\n        return sampleFileStats;\n      })",
        "type": "test-case"
      },
      {
        "title": "should prompt for configuration",
        "code": "it('should prompt for configuration', async () => {\n      const defaultConfig = { name: 'default-project' };\n      \n      vi.mocked(cliScript.promptForConfig).mockImplementationOnce(async (config) => {\n        const questions = [\n          { type: 'input', name: 'name', message: 'Project name:', default: config?.name || 'my-project' }\n        ];\n        inquirer.prompt(questions as any);\n        return sampleConfig;\n      })",
        "type": "test-case"
      },
      {
        "title": "should use default values when no config is provided",
        "code": "it('should use default values when no config is provided', async () => {\n      vi.mocked(cliScript.promptForConfig).mockImplementationOnce(async () => {\n        const questions = [\n          { type: 'input', name: 'name', message: 'Project name:', default: 'my-project' }\n        ];\n        inquirer.prompt(questions as any);\n        return sampleConfig;\n      })",
        "type": "test-case"
      },
      {
        "title": "should process files based on configuration",
        "code": "it('should process files based on configuration', () => {\n      vi.mocked(fs.existsSync).mockReturnValueOnce(false);\n      \n      vi.mocked(cliScript.processFiles).mockImplementationOnce((config) => {\n        console.log(`Processing files for project: ${config.name}`);\n        \n        if (!fs.existsSync(config.outputDir)) {\n          fs.mkdirSync(config.outputDir, { recursive: true })",
        "type": "test-case"
      },
      {
        "title": "should log verbose information when verbose is enabled",
        "code": "it('should log verbose information when verbose is enabled', () => {\n      const verboseConfig = { ...sampleConfig, verbose: true };\n      \n      cliScript.processFiles(verboseConfig);\n      \n      expect(console.log).toHaveBeenCalledTimes(verboseConfig.features.length + 1);\n    })",
        "type": "test-case"
      },
      {
        "title": "should handle errors during processing",
        "code": "it('should handle errors during processing', () => {\n      vi.mocked(fs.existsSync).mockReturnValueOnce(false);\n      \n      vi.mocked(cliScript.processFiles).mockImplementationOnce((config) => {\n        try {\n          console.log(`Processing files for project: ${config.name}`);\n          \n          if (!fs.existsSync(config.outputDir)) {\n            fs.mkdirSync(config.outputDir, { recursive: true })",
        "type": "test-case"
      },
      {
        "title": "should run the CLI with existing config",
        "code": "it('should run the CLI with existing config', async () => {\n      (inquirer.prompt as any).mockResolvedValueOnce({ confirmConfig: true })",
        "type": "test-case"
      },
      {
        "title": "should prompt for new config when user rejects existing config",
        "code": "it('should prompt for new config when user rejects existing config', async () => {\n      vi.mocked(cliScript.main).mockImplementationOnce(async (args) => {\n        const configPath = args[0] || './config.json';\n        fs.existsSync(configPath);\n        const result = await inquirer.prompt([{ type: 'confirm', name: 'confirmConfig', message: 'Use existing configuration?' }]) as { confirmConfig: boolean };\n        if (!result.confirmConfig) {\n          const newConfig = await cliScript.promptForConfig();\n          cliScript.writeConfig(configPath, newConfig);\n        }\n        return 0;\n      })",
        "type": "test-case"
      },
      {
        "title": "should create new config when config file does not exist",
        "code": "it('should create new config when config file does not exist', async () => {\n      vi.mocked(cliScript.main).mockImplementationOnce(async (args) => {\n        const configPath = args[0] || './config.json';\n        if (!fs.existsSync(configPath)) {\n          const newConfig = await cliScript.promptForConfig();\n          cliScript.writeConfig(configPath, newConfig);\n        }\n        return 0;\n      })",
        "type": "test-case"
      },
      {
        "title": "should handle errors in the main function",
        "code": "it('should handle errors in the main function', async () => {\n      vi.mocked(inquirer.prompt).mockRejectedValueOnce(new Error('Prompt error'));\n      vi.mocked(cliScript.main).mockImplementationOnce(async () => {\n        console.error('Error in CLI application: Prompt error');\n        return 1;\n      })",
        "type": "test-case"
      },
      {
        "title": "should use default config path when no arguments provided",
        "code": "it('should use default config path when no arguments provided', async () => {\n      (inquirer.prompt as any).mockResolvedValueOnce({ confirmConfig: true })",
        "type": "test-case"
      },
      {
        "title": "should capture console output",
        "code": "it('should capture console output', () => {\n      cliScript.processFiles(sampleConfig);\n      \n      expect(mockConsoleLog).toHaveBeenCalledWith(`Processing files for project: ${sampleConfig.name}`);\n    })",
        "type": "test-case"
      },
      {
        "title": "should handle process exit",
        "code": "it('should handle process exit', () => {\n      const mockExit = vi.spyOn(process, 'exit').mockImplementation((code) => {\n        throw new Error(`Process exit with code: ${code}`);\n      })",
        "type": "test-case"
      },
      {
        "title": "should handle user input through inquirer",
        "code": "it('should handle user input through inquirer', async () => {\n      const userInput = {\n        name: 'user-project',\n        outputDir: './user-output',\n        features: ['database'],\n        verbose: false\n      };\n      \n      vi.mocked(inquirer.prompt).mockResolvedValueOnce(userInput);\n      \n      vi.mocked(cliScript.promptForConfig).mockImplementationOnce(async () => {\n        const questions = [\n          { type: 'input', name: 'name', message: 'Project name:' },\n          { type: 'input', name: 'outputDir', message: 'Output directory:' },\n          { type: 'checkbox', name: 'features', message: 'Select features:' },\n          { type: 'confirm', name: 'verbose', message: 'Enable verbose logging?' }\n        ];\n        return await inquirer.prompt(questions as any) as any;\n      })",
        "type": "test-case"
      },
      {
        "title": "Testing Node.js Scripts",
        "code": "describe('Testing Node.js Scripts', () => {\n  const sampleConfig: Config = {\n    name: 'test-project',\n    outputDir: './test-output',\n    features: ['api', 'ui'],\n    verbose: true\n  };\n  \n  const sampleFileStats: FileStats[] = [\n    {\n      filename: 'test.json',\n      size: 1024,\n      created: new Date('2023-01-01'),\n      modified: new Date('2023-01-02')\n    }\n  ];\n  \n  beforeEach(() => {\n    vi.resetAllMocks();\n    \n    console.log = mockConsoleLog;\n    console.error = mockConsoleError;\n    \n    vi.mocked(fs.existsSync).mockReturnValue(true);\n    vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(sampleConfig));\n    vi.mocked(fs.readdirSync).mockReturnValue([{ name: 'test.json', isFile: () => true } as unknown as fs.Dirent]);\n    vi.mocked(fs.statSync).mockReturnValue({\n      isFile: () => true,\n      size: 1024,\n      birthtime: new Date('2023-01-01'),\n      mtime: new Date('2023-01-02'),\n      dev: 1,\n      ino: 1,\n      mode: 1,\n      nlink: 1,\n      uid: 1,\n      gid: 1,\n      rdev: 1,\n      blksize: 1,\n      blocks: 1,\n      atimeMs: 1,\n      mtimeMs: 1,\n      ctimeMs: 1,\n      birthtimeMs: 1,\n      atime: new Date(),\n      ctime: new Date()\n    } as unknown as fs.Stats);\n    \n    // Mock inquirer module\n    vi.mocked(inquirer.prompt).mockResolvedValue(sampleConfig);\n    \n    vi.mocked(cliScript.readConfig).mockImplementation((path: string) => {\n      return sampleConfig;\n    })",
        "type": "describe-block"
      },
      {
        "title": "Testing File System Operations",
        "code": "describe('Testing File System Operations', () => {\n    it('should read configuration file correctly', () => {\n      const configPath = './config.json';\n      \n      vi.mocked(cliScript.readConfig).mockImplementationOnce((path) => {\n        fs.readFileSync(path, 'utf8');\n        return sampleConfig;\n      })",
        "type": "describe-block"
      },
      {
        "title": "Testing User Interaction",
        "code": "describe('Testing User Interaction', () => {\n    it('should prompt for configuration', async () => {\n      const defaultConfig = { name: 'default-project' };\n      \n      vi.mocked(cliScript.promptForConfig).mockImplementationOnce(async (config) => {\n        const questions = [\n          { type: 'input', name: 'name', message: 'Project name:', default: config?.name || 'my-project' }\n        ];\n        inquirer.prompt(questions as any);\n        return sampleConfig;\n      })",
        "type": "describe-block"
      },
      {
        "title": "Testing Process Functionality",
        "code": "describe('Testing Process Functionality', () => {\n    it('should process files based on configuration', () => {\n      vi.mocked(fs.existsSync).mockReturnValueOnce(false);\n      \n      vi.mocked(cliScript.processFiles).mockImplementationOnce((config) => {\n        console.log(`Processing files for project: ${config.name}`);\n        \n        if (!fs.existsSync(config.outputDir)) {\n          fs.mkdirSync(config.outputDir, { recursive: true })",
        "type": "describe-block"
      },
      {
        "title": "Testing Main CLI Function",
        "code": "describe('Testing Main CLI Function', () => {\n    it('should run the CLI with existing config', async () => {\n      (inquirer.prompt as any).mockResolvedValueOnce({ confirmConfig: true })",
        "type": "describe-block"
      },
      {
        "title": "Testing Process Arguments and Environment",
        "code": "describe('Testing Process Arguments and Environment', () => {\n    it('should use default config path when no arguments provided', async () => {\n      (inquirer.prompt as any).mockResolvedValueOnce({ confirmConfig: true })",
        "type": "describe-block"
      },
      {
        "title": "Testing with Mocked Standard Input/Output",
        "code": "describe('Testing with Mocked Standard Input/Output', () => {\n    it('should handle user input through inquirer', async () => {\n      const userInput = {\n        name: 'user-project',\n        outputDir: './user-output',\n        features: ['database'],\n        verbose: false\n      };\n      \n      vi.mocked(inquirer.prompt).mockResolvedValueOnce(userInput);\n      \n      vi.mocked(cliScript.promptForConfig).mockImplementationOnce(async () => {\n        const questions = [\n          { type: 'input', name: 'name', message: 'Project name:' },\n          { type: 'input', name: 'outputDir', message: 'Output directory:' },\n          { type: 'checkbox', name: 'features', message: 'Select features:' },\n          { type: 'confirm', name: 'verbose', message: 'Enable verbose logging?' }\n        ];\n        return await inquirer.prompt(questions as any) as any;\n      })",
        "type": "describe-block"
      }
    ]
  }
]